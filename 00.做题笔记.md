


## 144. 二叉树的前序遍历
1. 递归调用版本挺容易实现的， 代码也很简洁。 12ms，29.45%
2. 使用栈迭代的方式实现确实比较快一些，用了8ms， 77.3%。
3. 还是要注意入栈的顺序，right先入栈。

## [145] 二叉树的后序遍历
1. 注意标识已经访问的对象就可以了。
这个难度竟然是困难的， 而 590是简单的。

### [236] 二叉树的最近公共祖先
1. 使用递归方式实现  8m
深度优先搜索，如果一个节点和它的左右子树找到了两个节点， 则找到公共祖先节点
由于是深度优先搜索，所以是最近的公共祖先节点
递归思想很好用，甚至可以不需要关心具体的实现细节，只要步骤上没错就能得到答案。
运行速度也比较快，会消耗内存

2. 非递归版本，找到p，q的父节点，再比较。  21ms， 看似操作变少了，反而更慢。

## [589] N叉树的前序遍历
从590拷贝代码过来，把函数名也拷贝过来了。
拷贝代码是个很容易出错的行为，要留心。

## [590] N叉树的后序遍历
迭代方式求解注意两点
1. children元素入栈的顺序从右向左
2. 判断是否pop的条件还要判断这个元素是否已经访问过，这样才不会产生死循环
